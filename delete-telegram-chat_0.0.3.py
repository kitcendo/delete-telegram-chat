# 0.0.2 แก้ไขการหา json หลังจากถูกแปลงเป็น EXE
# 0.0.3 ปรับปรุงฟังชั่น restart_bot ให้มั่นใจว่าทำงานใน windows ได้

# =====================================================================================
# ส่วนที่ 1: การนำเข้าเครื่องมือ (Import Libraries)
# เราจะบอก Python ว่าโปรเจกต์นี้ต้องใช้ "เครื่องมือ" หรือ "ไลบรารี" อะไรบ้าง
# =====================================================================================

import json         # เครื่องมือสำหรับอ่านและเขียนไฟล์ที่มีนามสกุล .json (ใช้กับไฟล์ตั้งค่า)
import asyncio      # เครื่องมือสำหรับจัดการงานที่ต้องทำพร้อมๆ กัน (เช่น รับข้อความไปพร้อมๆ กับแสดงสถานะ)
import sys          # เครื่องมือสำหรับจัดการการทำงานพื้นฐานของ Python เช่น การแสดงผลใน Terminal หรือการออกจากโปรแกรม
import logging      # เครื่องมือสำหรับบันทึกการทำงานของโปรแกรม (ดีกว่า print เพราะบอกเวลาและระดับความสำคัญได้)
import os           # เครื่องมือสำหรับจัดการกับไฟล์และโฟลเดอร์ในคอมพิวเตอร์ของเรา (เช่น หาตำแหน่งไฟล์)
import subprocess   # เครื่องมือสำหรับสั่งให้โปรแกรมรันคำสั่งของระบบปฏิบัติการ (ใช้ตอนรีสตาร์ทตัวเอง)
from telethon import TelegramClient, events, errors  # หัวใจหลัก: เครื่องมือสำหรับเชื่อมต่อกับ Telegram และดักจับเหตุการณ์ต่างๆ
from telethon.tl.types import Channel, Chat        # เครื่องมือย่อยสำหรับระบุประเภทของกลุ่ม (Supergroup หรือกลุ่มธรรมดา)
from datetime import datetime                      # เครื่องมือสำหรับจัดการเรื่องวันและเวลา (เพื่อบันทึกเวลาที่ลบข้อความ)
from asyncio import Lock                           # เครื่องมือพิเศษ "แม่กุญแจ" เพื่อป้องกันไม่ให้งานที่สำคัญทำงานพร้อมกันจนเกิดปัญหา

# =====================================================================================
# ส่วนที่ 2: การตั้งค่าเริ่มต้น (Initial Setup)
# เราจะตั้งค่าพื้นฐานที่โปรแกรมต้องใช้ เช่น การตั้งค่า Logger และสร้างตัวแปรกลาง
# =====================================================================================

# --- ตั้งค่าระบบบันทึก Log ---
logger = logging.getLogger('telegram_bot')  # สร้าง "สมุดบันทึก" ประจำตัวของบอท
logger.setLevel(logging.INFO)               # ตั้งค่าว่าให้บันทึกเรื่องราวที่มีความสำคัญระดับ "ข้อมูลทั่วไป" (INFO) ขึ้นไป
handler = logging.StreamHandler(sys.stdout) # กำหนดให้สมุดบันทึกนี้แสดงผลออกมาทางหน้าจอ Terminal
formatter = logging.Formatter(              # กำหนดรูปแบบการจดบันทึก ให้มี "วัน-เวลา - ระดับความสำคัญ - ข้อความ"
    '%(asctime)s - %(levelname)s - %(message)s'
)
handler.setFormatter(formatter)             # นำรูปแบบที่สร้างไว้ไปใช้กับที่แสดงผลบนหน้าจอ
if not logger.handlers:                     # ตรวจสอบก่อนว่ามีสมุดบันทึกอยู่แล้วหรือยัง (ป้องกันการสร้างซ้ำซ้อน)
    logger.addHandler(handler)              # ถ้ายังไม่มี ก็ให้เพิ่มสมุดบันทึกนี้เข้าไปในระบบ

# --- สร้างตัวแปรกลางที่ใช้ร่วมกัน ---
delete_lock = Lock()          # สร้าง "แม่กุญแจ" 1 ดอก สำหรับใช้ตอนลบข้อความ เพื่อให้ลบทีละงาน ไม่ให้แย่งกัน
admin_groups_cache = {}       # สร้าง "สมองส่วนความจำระยะสั้น" (Cache) เพื่อเก็บข้อมูลว่าเราเป็นแอดมินกลุ่มไหนบ้าง จะได้ไม่ต้องเช็คซ้ำๆ ให้เสียเวลา

# =====================================================================================
# ส่วนที่ 3: ฟังก์ชันผู้ช่วย (Helper Functions)
# เราจะสร้างฟังก์ชันเล็กๆ ที่ทำงานเฉพาะทาง เพื่อให้โค้ดหลักของเราอ่านง่ายและเป็นระเบียบ
# ฟังก์ชันเหล่านี้ต้องถูกสร้าง "ก่อน" ที่จะถูกเรียกใช้
# =====================================================================================

def get_base_path():
    """
    ฟังก์ชันนักหาแผนที่เวอร์ชันสมบูรณ์:
    หาที่อยู่ของโฟลเดอร์ที่โปรแกรมกำลังทำงานอยู่จริงๆ
    - ถ้าเป็นไฟล์ .py ปกติ จะได้ที่อยู่ของโฟลเดอร์นั้น
    - ถ้าเป็นไฟล์ .exe จะได้ที่อยู่ของโฟลเดอร์ที่ไฟล์ .exe วางอยู่
    """
    if getattr(sys, 'frozen', False):
        # ถ้าโปรแกรมถูก 'แช่แข็ง' (frozen) ให้เป็น .exe
        # ให้ใช้ที่อยู่ของไฟล์ .exe นั้นเป็นหลัก
        base_path = os.path.dirname(sys.executable)
    else:
        # ถ้ารันเป็นสคริปต์ .py ปกติ
        # ให้ใช้ที่อยู่ของไฟล์ .py นั้น
        base_path = os.path.abspath(".")
    return base_path

def load_config():
    """
    ฟังก์ชันพนักงานจัดเตรียม: อ่านไฟล์ config.json เพื่อเอาข้อมูลสำคัญมาเตรียมไว้ให้พร้อมใช้งาน
    """
    config_path = os.path.join(get_base_path(), 'config.json')  # ใช้ "นักหาแผนที่" เพื่อหาไฟล์ config.json
    try: # ลองเปิดและอ่านไฟล์
        with open(config_path, 'r', encoding='utf-8') as file: # เปิดไฟล์ในโหมดอ่าน (r) และกำหนดให้รองรับภาษาไทย (utf-8)
            config = json.load(file) # ใช้เครื่องมือ json เพื่อแปลงเนื้อหาในไฟล์ให้ Python รู้จัก
        
        # ดึงค่าต่างๆ ออกมาจาก config ที่อ่านได้
        api_id = config['api_id']               # ดึง api_id
        api_hash = config['api_hash']           # ดึง api_hash
        phone = config['phone_number']          # ดึงเบอร์โทรศัพท์
        # ดึงรายการคำต้องห้าม และแปลงทุกคำให้เป็นตัวพิมพ์เล็กทั้งหมดเพื่อง่ายต่อการเปรียบเทียบ
        forbidden_words = set(word.lower() for word in config.get('forbidden_words', []))

        # คืนค่าทั้งหมดที่ดึงมาได้กลับไป
        return api_id, api_hash, phone, forbidden_words

    except FileNotFoundError: # แต่ถ้าหาไฟล์ config.json ไม่เจอ
        logger.error(f"ไม่พบไฟล์ config.json ที่ {config_path}") # บันทึก Log ข้อผิดพลาด
        sys.exit("Error: config.json not found.") # สั่งให้โปรแกรมปิดตัวลงพร้อมข้อความแจ้งเตือน

    except KeyError as e: # แต่ถ้าในไฟล์มีข้อมูลไม่ครบ (ขาด key ที่จำเป็น)
        logger.error(f"ในไฟล์ config.json ขาด key ที่จำเป็น: {e}") # บันทึก Log บอกว่าขาด key อะไรไป
        sys.exit(f"Error: Missing key in config.json: {e}") # สั่งให้โปรแกรมปิดตัวลง

# --- เริ่มใช้งานฟังก์ชันเพื่อโหลดค่า Config ---
api_id, api_hash, phone_number, forbidden_words = load_config() # เรียก "พนักงานจัดเตรียม" ให้ทำงาน แล้วเก็บค่าที่ได้ไว้ในตัวแปร

# --- สร้างตัวตนของบอท (Client) ---
client = TelegramClient(
    'session_name',     # ตั้งชื่อไฟล์ session ที่จะใช้เก็บข้อมูลการล็อกอิน (ตั้งเป็นอะไรก็ได้)
    api_id,             # ใส่ "เลขบัตรประชาชน" ของแอป
    api_hash,           # ใส่ "กุญแจลับ" ของแอป
)

def contains_forbidden_words(message):
    """
    ฟังก์ชันนักสืบคำ: ตรวจสอบว่าในประโยคมีคำต้องห้ามอยู่หรือไม่
    """
    if not message or not forbidden_words: # ถ้าไม่มีข้อความ หรือ ไม่มีรายการคำต้องห้าม
        return False # ก็ไม่ต้องทำอะไรต่อ คืนค่าว่า "ไม่เจอ"

    # แปลงข้อความทั้งหมดเป็นตัวพิมพ์เล็ก แล้วเช็คว่ามีคำใดในรายการ `forbidden_words` อยู่ในข้อความหรือไม่
    return any(word in message.lower() for word in forbidden_words)

# =====================================================================================
# ส่วนที่ 4: ฟังก์ชันการทำงานหลัก (Core Logic Functions)
# นี่คือส่วนของตรรกะที่ซับซ้อนขึ้นมา เช่น การเช็คสิทธิ์ หรือการลบข้อความ
# =====================================================================================

async def check_admin_rights(dialog):
    """
    ฟังก์ชันยามรักษาความปลอดภัย: ตรวจสอบว่าเรามีสิทธิ์เป็นแอดมินในกลุ่มนั้นๆ หรือไม่
    """
    dialog_id = dialog.id # ดึง ID ของกลุ่มออกมาใช้เป็น key
    if dialog_id in admin_groups_cache: # ขั้นแรก, ลองค้นหาใน "สมองส่วนความจำระยะสั้น" ก่อน
        return admin_groups_cache[dialog_id] # ถ้าเจอ ก็คืนค่าจากความจำไปเลย ไม่ต้องถาม Telegram ให้เสียเวลา

    try: # ถ้าในความจำไม่มี, ก็ต้องลองถาม Telegram (อาจเกิดข้อผิดพลาดได้)
        me = await client.get_me() # ถาม Telegram ว่า "ฉันคือใคร?" เพื่อเอา ID ของเรา
        # ถาม Telegram ตรงๆ ว่า "ฉัน (me) มีสิทธิ์อะไรบ้างในกลุ่มนี้ (dialog)"
        permissions = await client.get_permissions(dialog, me)

        # ตรวจสอบสิทธิ์ที่ได้มา
        if permissions.is_creator or (permissions.is_admin and permissions.delete_messages):
            # ถ้าเราเป็น "ผู้สร้างห้อง" หรือ เป็น "แอดมินที่มีสิทธิ์ลบข้อความ"
            is_admin_with_rights = True # ให้ถือว่าเรามีสิทธิ์
        else:
            is_admin_with_rights = False # นอกนั้นถือว่าไม่มีสิทธิ์

        admin_groups_cache[dialog_id] = is_admin_with_rights # เอาผลลัพธ์ที่ได้ไป "จดจำ" ไว้ใน Cache
        return is_admin_with_rights # คืนค่าผลลัพธ์นั้นกลับไป

    except Exception as e: # หากการตรวจสอบสิทธิ์เกิดข้อผิดพลาดใดๆ ก็ตาม
        # บันทึก Log ข้อผิดพลาดเอาไว้ แต่ไม่ทำให้โปรแกรมหยุดทำงาน
        logger.warning(f"ไม่สามารถตรวจสอบสิทธิ์ในกลุ่ม '{getattr(dialog, 'title', dialog_id)}' ได้เนื่องจาก: {e}")
        admin_groups_cache[dialog_id] = False # จดจำไว้ว่ากลุ่มนี้มีปัญหา ตรวจสอบไม่ได้ (ให้ถือว่าไม่มีสิทธิ์)
        return False # คืนค่าว่า "ไม่มีสิทธิ์"

async def delete_message_task(event):
    """
    ฟังก์ชันทีมทำความสะอาด: ทำหน้าที่ลบข้อความที่ได้รับมอบหมายมาเพียงอย่างเดียว
    """
    async with delete_lock: # ขอก่อนว่าจะใช้ "แม่กุญแจ" (เพื่อให้แน่ใจว่ามีทีมทำความสะอาดเข้าทำงานได้ทีละทีม)
        try: # ลองลบข้อความ
            await event.delete() # สั่งลบข้อความจาก Event ที่ได้รับมา
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S") # ดึงเวลาปัจจุบัน
            chat_title = getattr(event.chat, 'title', event.chat_id) # ดึงชื่อกลุ่ม (ถ้าไม่มีชื่อก็ใช้ ID แทน)
            logger.info(f"ลบข้อความสำเร็จในกลุ่ม '{chat_title}' เวลา {now}") # บันทึก Log ความสำเร็จ
        except errors.MessageDeleteForbiddenError: # แต่ถ้า Telegram ตอบกลับมาว่า "ไม่มีสิทธิ์ลบ"
            logger.warning(f"ไม่มีสิทธิ์ลบข้อความในกลุ่ม '{chat_title}'. อาจถูกลดสิทธิ์?") # แจ้งเตือนใน Log
            admin_groups_cache.pop(event.chat_id, None) # ลบความจำเกี่ยวกับสิทธิ์ในกลุ่มนี้ทิ้ง (เพื่อให้ครั้งหน้าเช็คใหม่)
        except Exception as e: # หากเกิดข้อผิดพลาดอื่นๆ นอกเหนือจากนี้
            logger.error(f"เกิดข้อผิดพลาดในการลบข้อความ: {e}") # ให้บันทึก Log ข้อผิดพลาดนั้นไว้

async def process_message_event(event):
    """
    ฟังก์ชันผู้จัดการ: เป็นศูนย์กลางในการตัดสินใจเมื่อได้รับ Event เกี่ยวกับข้อความ
    """
    if not event.message or not event.message.message: # ตรวจสอบก่อนว่า Event ที่ได้มามี "ข้อความ" จริงๆ หรือไม่
        return # ถ้าไม่มี ก็ไม่ต้องทำอะไรต่อ

    dialog = await event.get_chat() # ดึงข้อมูลของกลุ่มที่เกิดเหตุการณ์
    # ถ้าเป็นกลุ่มจริง (ไม่ใช่แชทส่วนตัว) และข้อความนั้นไม่ใช่ข้อความที่เราส่งเอง
    if isinstance(dialog, (Channel, Chat)) and not event.message.out:
        is_admin = await check_admin_rights(dialog) # ให้ "ยามรักษาความปลอดภัย" ไปเช็คสิทธิ์
        if is_admin and contains_forbidden_words(event.message.message): # ถ้าเรามีสิทธิ์ และ "นักสืบ" พบคำต้องห้าม
            # ให้สร้าง "ใบสั่งงาน" แล้วโยนไปให้ "ทีมทำความสะอาด" จัดการเป็นงานเบื้องหลัง
            # การทำแบบนี้จะทำให้ผู้จัดการพร้อมรับเรื่องใหม่ได้ทันที โดยไม่ต้องรอให้งานเก่าเสร็จ
            asyncio.create_task(delete_message_task(event))

# =====================================================================================
# ส่วนที่ 5: ตัวดักจับเหตุการณ์ (Event Handlers)
# เราจะใช้ "ป้ายกำกับพิเศษ" (@) เพื่อบอก Telethon ว่าถ้ามีเหตุการณ์แบบนี้เกิดขึ้น ให้ไปเรียกฟังก์ชันไหนทำงาน
# =====================================================================================

@client.on(events.NewMessage)
async def handle_new_message(event):
    """
    เซ็นเซอร์จับข้อความใหม่: ฟังก์ชันนี้จะทำงานทุกครั้งที่มี "ข้อความใหม่" ถูกส่งเข้ามาในกลุ่ม
    """
    await process_message_event(event) # เมื่อจับสัญญาณได้ ก็ส่งเรื่องต่อให้ "ผู้จัดการ" ทันที

@client.on(events.MessageEdited)
async def handle_message_edited(event):
    """
    เซ็นเซอร์จับการแก้ไขข้อความ: ฟังก์ชันนี้จะทำงานทุกครั้งที่มีคน "แก้ไข" ข้อความเก่า
    (นี่คือไม้ตายสำหรับจัดการสแปมเมอร์ที่ส่งข้อความขาวสะอาดเข้ามาก่อน แล้วค่อยแก้ไขเป็นโฆษณา)
    """
    # บันทึก Log ไว้เพื่อดูว่าเราจับการแก้ไขได้จริง (มีประโยชน์ตอนทดสอบ)
    logger.info(f"ตรวจพบการแก้ไขข้อความในกลุ่ม '{getattr(event.chat, 'title', event.chat_id)}', กำลังตรวจสอบ...")
    await process_message_event(event) # ส่งเรื่องต่อให้ "ผู้จัดการ" เช่นกัน

# =====================================================================================
# ส่วนที่ 6: ฟังก์ชันเสริมและส่วนที่ใช้รันโปรแกรม (Auxiliary & Main Execution)
# =====================================================================================

async def show_cute_status():
    """
    ฟังก์ชันตัวละครน่ารัก: แสดงสถานะว่าโปรแกรมกำลังทำงานอยู่ ไม่ได้ค้าง
    """
    cute_actions = ["(^_^)", "(o_o)", "(>_<)", "(-_-)", "(T_T)", "(*_*)", "(^o^)", "(@_@)", "(._. )", "( ^_^)/"]
    idx = 0 # ตัวชี้ตำแหน่งเริ่มต้น
    while True: # วนลูปไปเรื่อยๆ ไม่มีที่สิ้นสุด
        # พิมพ์ท่าทางน่ารักออกมาที่หน้าจอ พร้อมข้อความ ( \r คือการสั่งให้พิมพ์ทับที่เดิม)
        sys.stdout.write(f'\r{cute_actions[idx]} กำลังทำงาน...')
        sys.stdout.flush() # สั่งให้แสดงผลทันที ไม่ต้องรอ
        idx = (idx + 1) % len(cute_actions) # เลื่อนไปท่าทางถัดไป (ถ้าสุดแล้วให้วนกลับมาที่ 0)
        await asyncio.sleep(0.5) # หยุดรอ 0.5 วินาที ก่อนจะแสดงท่าทางถัดไป

async def restart_bot():
    """
    ฟังก์ชันปุ่มรีเซ็ตอัตโนมัติ: สั่งให้บอทรีสตาร์ทตัวเองทุกๆ 48 ชั่วโมง
    (เวอร์ชันนี้ถูกปรับให้เสถียรสูงสุดสำหรับ Windows โดยเฉพาะ)
    """
    await asyncio.sleep(48 * 3600)  # หยุดรอเป็นเวลา 48 ชั่วโมง
    logger.info("กำลังรีสตาร์ทบอทตามกำหนดเวลา (48 ชั่วโมง)...") # บันทึก Log

    # sys.argv คือ "สูตร" ในการรันโปรแกรมนี้ขึ้นมา
    # เช่น ['C:\\Path\\to\\your\\bot.exe'] เมื่อรันเป็น .exe

    # ตรวจสอบระบบปฏิบัติการที่เรากำลังทำงานอยู่
    if sys.platform == "win32":
        # --- ทางเลือกหลักสำหรับ Windows ---
        # บน Windows, วิธีที่เสถียรที่สุดคือการสร้างโปรเซสใหม่ขึ้นมาทำงานอิสระ
        # แล้วให้โปรเซสเก่า (ตัวแม่) ปิดตัวเองลง
        logger.info("ตรวจพบระบบปฏิบัติการ Windows, กำลังรีสตาร์ทด้วยวิธีสำหรับ Windows...")
        subprocess.Popen(sys.argv)
    else:
        # --- ทางเลือกสำหรับระบบปฏิบัติการอื่น (Linux/macOS) ---
        # บนระบบอื่น, เราสามารถใช้ os.execv เพื่อ 'แทนที่' โปรเซสปัจจุบันได้เลย
        # ซึ่งเป็นวิธีที่มีประสิทธิภาพสูงสำหรับระบบเหล่านั้น
        logger.info(f"ตรวจพบระบบปฏิบัติการ {sys.platform}, กำลังรีสตาร์ทด้วยวิธีสำหรับ Unix...")
        os.execv(sys.executable, sys.argv)
    
    # คำสั่งสำคัญ: หลังจากสั่งให้โปรแกรมใหม่เริ่มทำงานแล้ว
    # ให้โปรแกรมปัจจุบัน (ตัวเก่า) ปิดตัวเองลงทันที
    # นี่เป็นการการันตีว่าจะไม่มีโปรแกรม 2 ตัวทำงานซ้อนกัน
    logger.info("ส่งไม้ต่อสำเร็จ กำลังปิดโปรแกรมเก่า...")
    sys.exit()

async def main():
    """
    ฟังก์ชันหลักในการควบคุม: เป็นจุดศูนย์กลางที่สั่งให้ทุกอย่างเริ่มทำงาน
    """
    await client.start(phone=phone_number) # สั่งให้ "ตัวตนของบอท" เริ่มเชื่อมต่อกับ Telegram โดยใช้เบอร์โทร
    logger.info("บอทเริ่มทำงานแล้ว! พร้อมลบข้อความต้องห้าม!") # เมื่อเชื่อมต่อสำเร็จ ให้แสดงข้อความนี้

    # สั่งให้ฟังก์ชันเสริมทำงานเป็น "เบื้องหลัง" ไปพร้อมๆ กับการดักจับข้อความ
    asyncio.create_task(show_cute_status())
    asyncio.create_task(restart_bot())

    # สั่งให้บอททำงานไปเรื่อยๆ จนกว่าจะถูกตัดการเชื่อมต่อหรือปิดโปรแกรม
    await client.run_until_disconnected()


# --- จุดเริ่มต้นของการทำงานทั้งหมด ---
if __name__ == '__main__':
    # ประโยคนี้เป็นมาตรฐานของ Python หมายความว่า "เมื่อไฟล์นี้ถูกรันโดยตรง (ไม่ได้ถูกโปรแกรมอื่นดึงไปใช้)"
    try: # ลองรันฟังก์ชันหลัก
        asyncio.run(main())
    except (errors.ApiIdInvalidError, errors.ApiIdPublishedFloodError): # หากเกิดข้อผิดพลาดเกี่ยวกับ ApiId/Hash
        logger.error("ApiId หรือ ApiHash ไม่ถูกต้อง กรุณาตรวจสอบไฟล์ config.json")
    except Exception as e: # หากเกิดข้อผิดพลาดร้ายแรงอื่นๆ ที่ไม่ได้คาดคิด
        logger.critical(f"เกิดข้อผิดพลาดร้ายแรงที่ไม่สามารถทำงานต่อได้: {e}")